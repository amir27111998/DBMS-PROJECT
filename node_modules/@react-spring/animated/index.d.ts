import { SpringValue, Animatable, InterpolatorArgs, OneOrMore, Interpolatable, Interpolator, ElementType } from '@react-spring/shared';
export { createAnimatedInterpolation as interpolate } from '@react-spring/shared/globals';

declare function isAnimated(val: unknown): val is Animated;
declare abstract class Animated<Payload = unknown> {
    abstract getValue(): any;
    getAnimatedValue(): any;
    protected payload?: Payload;
    getPayload(): Payload | this;
    attach(): void;
    detach(): void;
    private children;
    getChildren(): Animated<unknown>[];
    addChild(child: Animated): void;
    removeChild(child: Animated): void;
}
declare abstract class AnimatedArray<Payload extends ReadonlyArray<any> = ReadonlyArray<unknown>> extends Animated<Payload> {
    protected payload: Payload;
    attach(): void;
    detach(): void;
}
declare class AnimatedObject<Payload extends {
    [key: string]: unknown;
}> extends Animated<Payload> {
    protected payload: Payload;
    constructor(payload: Payload);
    getValue(animated?: boolean): {
        [key: string]: any;
    };
    getAnimatedValue(): {
        [key: string]: any;
    };
    attach(): void;
    detach(): void;
}

declare class AnimatedValue<T = number> extends Animated implements SpringValue<T> {
    private animatedStyles;
    value: T;
    startPosition: number;
    lastPosition: number;
    lastVelocity?: number;
    startTime?: number;
    lastTime?: number;
    done: boolean;
    static from(value: any): Animated<unknown>;
    constructor(value: T);
    getValue(): T;
    setValue: (value: T, flush?: boolean) => void;
    interpolate<Out extends Animatable>(...args: InterpolatorArgs<T, Out>): SpringValue<Out>;
    reset(isActive: boolean): void;
    clearStyles(): void;
    private flush;
}

declare class AnimatedValueArray<T extends AnimatedValue[] = AnimatedValue[]> extends AnimatedArray<T> implements SpringValue<{
    [P in keyof T]: number;
}> {
    constructor(values: T);
    getValue(): {
        [P in keyof T]: number;
    };
    setValue(value: OneOrMore<number>, flush?: boolean): void;
    interpolate<Out extends Animatable>(...args: InterpolatorArgs<{
        [P in keyof T]: number;
    }, Out>): SpringValue<Out>;
}

/** Wrap each element type of `T` with the `Animated` type */
declare type AnimatedInputs<T extends Interpolatable> = {
    [P in keyof T]: Animated<T[P]>;
};
declare class AnimatedInterpolation<In extends Interpolatable = Interpolatable, Out extends Animatable = Animatable> extends AnimatedArray<AnimatedInputs<In>> implements SpringValue<Out> {
    calc: Interpolator<In>;
    constructor(parents: SpringValue | ReadonlyArray<SpringValue>, args: InterpolatorArgs<In, Out>);
    getValue(): Out;
    interpolate<T extends Animatable>(...args: InterpolatorArgs<Out, T>): SpringValue<T>;
}

/**
 * Wraps the `style` property with `AnimatedStyle`.
 */
declare class AnimatedProps<Props extends object & {
    style?: any;
} = {}> extends AnimatedObject<Props> {
    update: () => void;
    constructor(props: Props, callback: () => void);
}

declare class AnimatedStyle<Payload extends object & {
    transform?: Animated;
} = {}> extends AnimatedObject<Payload> {
    constructor(style?: Payload);
}

declare const createAnimatedComponent: CreateAnimated;
declare type WithExtend<T> = T & {
    extend: (...args: Array<AnimatedTarget | Array<AnimatedTarget>>) => WithExtend<T>;
};
/** Strings like "div", or components, or a map of components, or an array of those */
declare type AnimatedTarget = string | ElementType | {
    [key: string]: ElementType;
};
declare type CreateAnimated = (Component: string | ElementType) => any;
/** Add an `extend` method to your `animated` factory function */
declare function withExtend<T extends CreateAnimated>(animated: T, options?: {
    lowercase?: boolean;
}): WithExtend<T>;

export { Animated, AnimatedArray, AnimatedInterpolation, AnimatedObject, AnimatedProps, AnimatedStyle, AnimatedValue, AnimatedValueArray, WithExtend, createAnimatedComponent, isAnimated, withExtend };
