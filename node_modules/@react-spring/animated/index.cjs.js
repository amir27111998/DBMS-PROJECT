'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var shared = require('@react-spring/shared');
var _extends = _interopDefault(require('@babel/runtime/helpers/extends'));
var _inheritsLoose = _interopDefault(require('@babel/runtime/helpers/inheritsLoose'));
var G = require('@react-spring/shared/globals');
var _objectWithoutPropertiesLoose = _interopDefault(require('@babel/runtime/helpers/objectWithoutPropertiesLoose'));
var React = require('react');
var React__default = _interopDefault(React);

function isAnimated(val) {
  return val instanceof Animated;
}
var Animated =
/*#__PURE__*/
function () {
  function Animated() {
    this.children = [];
  }

  var _proto = Animated.prototype;

  _proto.getAnimatedValue = function getAnimatedValue() {
    return this.getValue();
  };

  _proto.getPayload = function getPayload() {
    return this.payload || this;
  };

  _proto.attach = function attach() {};

  _proto.detach = function detach() {};

  _proto.getChildren = function getChildren() {
    return this.children;
  };

  _proto.addChild = function addChild(child) {
    if (this.children.length === 0) this.attach();
    this.children.push(child);
  };

  _proto.removeChild = function removeChild(child) {
    var index = this.children.indexOf(child);
    this.children.splice(index, 1);
    if (this.children.length === 0) this.detach();
  };

  return Animated;
}();
var AnimatedArray =
/*#__PURE__*/
function (_Animated) {
  _inheritsLoose(AnimatedArray, _Animated);

  function AnimatedArray() {
    return _Animated.apply(this, arguments) || this;
  }

  var _proto2 = AnimatedArray.prototype;

  _proto2.attach = function attach() {
    var _this = this;

    this.payload.forEach(function (p) {
      return isAnimated(p) && p.addChild(_this);
    });
  };

  _proto2.detach = function detach() {
    var _this2 = this;

    this.payload.forEach(function (p) {
      return isAnimated(p) && p.removeChild(_this2);
    });
  };

  return AnimatedArray;
}(Animated);
var AnimatedObject =
/*#__PURE__*/
function (_Animated2) {
  _inheritsLoose(AnimatedObject, _Animated2);

  function AnimatedObject(payload) {
    var _this3;

    _this3 = _Animated2.call(this) || this;
    _this3.payload = payload;
    return _this3;
  }

  var _proto3 = AnimatedObject.prototype;

  _proto3.getValue = function getValue(animated) {
    if (animated === void 0) {
      animated = false;
    }

    var payload = {};

    for (var key in this.payload) {
      var value = this.payload[key];
      if (animated && !isAnimated(value)) continue;
      payload[key] = isAnimated(value) ? value[animated ? 'getAnimatedValue' : 'getValue']() : value;
    }

    return payload;
  };

  _proto3.getAnimatedValue = function getAnimatedValue() {
    return this.getValue(true);
  };

  _proto3.attach = function attach() {
    var _this4 = this;

    Object.values(this.payload).forEach(function (s) {
      return isAnimated(s) && s.addChild(_this4);
    });
  };

  _proto3.detach = function detach() {
    var _this5 = this;

    Object.values(this.payload).forEach(function (s) {
      return isAnimated(s) && s.removeChild(_this5);
    });
  };

  return AnimatedObject;
}(Animated);

var AnimatedStyle =
/*#__PURE__*/
function (_AnimatedObject) {
  _inheritsLoose(AnimatedStyle, _AnimatedObject);

  function AnimatedStyle(style) {
    if (style === void 0) {
      style = {};
    }

    return _AnimatedObject.call(this, style.transform && G.createAnimatedTransform ? _extends({}, style, {
      transform: G.createAnimatedTransform(style.transform)
    }) : style) || this;
  }

  return AnimatedStyle;
}(AnimatedObject);

/**
 * Animated works by building a directed acyclic graph of dependencies
 * transparently when you render your Animated components.
 *
 *               new Animated.Value(0)
 *     .interpolate()        .interpolate()    new Animated.Value(1)
 *         opacity               translateY      scale
 *          style                         transform
 *         View#234                         style
 *                                         View#123
 *
 * A) Top Down phase
 * When an AnimatedValue is updated, we recursively go down through this
 * graph in order to find leaf nodes: the views that we flag as needing
 * an update.
 *
 * B) Bottom Up phase
 * When a view is flagged as needing an update, we recursively go back up
 * in order to build the new value that it needs. The reason why we need
 * this two-phases process is to deal with composite props such as
 * transform which can receive values from multiple parents.
 */

function addAnimatedStyles(node, styles) {
  if ('update' in node) {
    styles.add(node);
  } else {
    node.getChildren().forEach(function (child) {
      return addAnimatedStyles(child, styles);
    });
  }
}

var AnimatedValue =
/*#__PURE__*/
function (_Animated) {
  _inheritsLoose(AnimatedValue, _Animated);

  function AnimatedValue(value) {
    var _this;

    _this = _Animated.call(this) || this;
    _this.animatedStyles = new Set();
    _this.done = false;

    _this.setValue = function (value, flush) {
      if (flush === void 0) {
        flush = true;
      }

      _this.value = value;
      if (flush) _this.flush();
    };

    _this.value = value;

    if (shared.is.num(value)) {
      _this.startPosition = value;
      _this.lastPosition = value;
    }

    return _this;
  }

  AnimatedValue.from = function from(value) {
    return isAnimated(value) ? value : new AnimatedValue(value);
  };

  var _proto = AnimatedValue.prototype;

  _proto.getValue = function getValue() {
    return this.value;
  };

  _proto.interpolate = function interpolate() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return G.createAnimatedInterpolation.apply(void 0, [this].concat(args));
  };

  _proto.reset = function reset(isActive) {
    if (shared.is.num(this.value)) {
      this.startPosition = this.value;
      this.lastPosition = this.value;
      this.lastVelocity = isActive ? this.lastVelocity : undefined;
      this.lastTime = isActive ? this.lastTime : undefined;
      this.startTime = G.now();
    }

    this.done = false;
    this.animatedStyles.clear();
  };

  _proto.clearStyles = function clearStyles() {
    this.animatedStyles.clear();
  };

  _proto.flush = function flush() {
    if (this.animatedStyles.size === 0) {
      addAnimatedStyles(this, this.animatedStyles);
    }

    this.animatedStyles.forEach(function (animatedStyle) {
      return animatedStyle.update();
    });
  };

  return AnimatedValue;
}(Animated);

var AnimatedValueArray =
/*#__PURE__*/
function (_AnimatedArray) {
  _inheritsLoose(AnimatedValueArray, _AnimatedArray);

  function AnimatedValueArray(values) {
    var _this;

    _this = _AnimatedArray.call(this) || this;
    _this.payload = values;
    return _this;
  }

  var _proto = AnimatedValueArray.prototype;

  _proto.getValue = function getValue() {
    return this.payload.map(function (v) {
      return v.getValue();
    });
  };

  _proto.setValue = function setValue(value, flush) {
    var _this2 = this;

    if (flush === void 0) {
      flush = true;
    }

    if (shared.is.arr(value)) {
      if (value.length === this.payload.length) {
        value.forEach(function (v, i) {
          return _this2.payload[i].setValue(v, flush);
        });
      }
    } else {
      this.payload.forEach(function (p) {
        return p.setValue(value, flush);
      });
    }
  };

  _proto.interpolate = function interpolate() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return G.createAnimatedInterpolation.apply(void 0, [this].concat(args));
  };

  return AnimatedValueArray;
}(AnimatedArray);

var AnimatedInterpolation =
/*#__PURE__*/
function (_AnimatedArray) {
  _inheritsLoose(AnimatedInterpolation, _AnimatedArray);

  function AnimatedInterpolation(parents, args) {
    var _this;

    _this = _AnimatedArray.call(this) || this;
    _this.calc = shared.createInterpolator.apply(void 0, args);
    _this.payload = Array.isArray(parents) ? parents.map(AnimatedValue.from) : parents instanceof AnimatedValueArray ? parents.getPayload() : [parents];
    return _this;
  }

  var _proto = AnimatedInterpolation.prototype;

  _proto.getValue = function getValue() {
    var args = this.payload.map(function (value) {
      return value.getValue();
    });
    return this.calc.apply(this, args);
  };

  _proto.interpolate = function interpolate() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return G.createAnimatedInterpolation.apply(void 0, [this].concat(args));
  };

  return AnimatedInterpolation;
}(AnimatedArray);

shared.Globals.assign({
  createAnimatedStyle: function createAnimatedStyle(style) {
    return new AnimatedStyle(style);
  },
  createAnimatedInterpolation: function createAnimatedInterpolation(parents) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    return new AnimatedInterpolation(parents, args);
  }
});

/**
 * Wraps the `style` property with `AnimatedStyle`.
 */

var AnimatedProps =
/*#__PURE__*/
function (_AnimatedObject) {
  _inheritsLoose(AnimatedProps, _AnimatedObject);

  function AnimatedProps(props, callback) {
    var _this;

    _this = _AnimatedObject.call(this, props.style && G.createAnimatedStyle ? _extends({}, props, {
      style: G.createAnimatedStyle(props.style)
    }) : props) || this;
    _this.update = callback;

    _this.attach();

    return _this;
  }

  return AnimatedProps;
}(AnimatedObject);

var createAnimatedComponent = function createAnimatedComponent(Component) {
  return React.forwardRef(function (props, ref) {
    var propsAnimated = React.useRef(null);
    var forceUpdate = shared.useForceUpdate();
    var node = React.useRef(null);
    var attachProps = React.useCallback(function (props) {
      var oldPropsAnimated = propsAnimated.current;

      var callback = function callback() {
        var didUpdate = !!node.current && G.applyAnimatedValues(node.current, propsAnimated.current.getAnimatedValue()); // If no referenced node has been found, or the update target didn't have a
        // native-responder, then forceUpdate the animation ...

        if (didUpdate === false) forceUpdate();
      };

      propsAnimated.current = new AnimatedProps(props, callback);
      oldPropsAnimated && oldPropsAnimated.detach();
      return propsAnimated.current.getValue();
    }, []);
    shared.useOnce(function () {
      return function () {
        propsAnimated.current && propsAnimated.current.detach();
      };
    }); // TODO: Avoid special case for scrollTop/scrollLeft

    var _attachProps = attachProps(props),
        scrollTop = _attachProps.scrollTop,
        scrollLeft = _attachProps.scrollLeft,
        animatedProps = _objectWithoutPropertiesLoose(_attachProps, ["scrollTop", "scrollLeft"]); // Functions cannot have refs (see #569)


    var refFn = !shared.is.fun(Component) || Component.prototype.isReactComponent ? function (value) {
      return node.current = updateRef(ref, value);
    } : void 0;
    return React__default.createElement(Component, Object.assign({}, animatedProps, {
      ref: refFn
    }));
  });
};

function updateRef(ref, value) {
  if (ref) {
    if (shared.is.fun(ref)) ref(value);else ref.current = value;
  }

  return value;
}
/** Add an `extend` method to your `animated` factory function */


function withExtend(animated, options) {
  if (options === void 0) {
    options = {};
  }

  var self = animated;

  var extend = function extend(arg, overrideKey) {
    // Arrays avoid passing their index to `extend`
    if (shared.is.arr(arg)) {
      return arg.forEach(function (arg) {
        return extend(arg);
      });
    } // Object keys are always used over value inspection


    if (shared.is.obj(arg)) {
      for (var _key in arg) {
        extend(arg[_key], _key);
      }

      return;
    } // Use the `overrideKey` or inspect the value for a key


    var key = shared.is.str(overrideKey) ? overrideKey : shared.is.str(arg) ? arg : arg && shared.is.str(arg.displayName) ? arg.displayName : shared.is.fun(arg) ? arg.name : ''; // This lowercases the first letter of the key

    if (options.lowercase) {
      key = key[0].toLowerCase() + key.slice(1);
    } // NOTE(typescript): Properties are not yet inferred from the arguments of
    // the `extend` method and then attached to the `animated` function via
    // the return type.


    self[key] = animated(arg);
  };

  self.extend = function () {
    for (var _len = arguments.length, args = new Array(_len), _key2 = 0; _key2 < _len; _key2++) {
      args[_key2] = arguments[_key2];
    }

    args.forEach(function (arg) {
      return extend(arg);
    });
    return self;
  };

  return self;
}

Object.defineProperty(exports, 'interpolate', {
  enumerable: true,
  get: function () {
    return G.createAnimatedInterpolation;
  }
});
exports.Animated = Animated;
exports.AnimatedArray = AnimatedArray;
exports.AnimatedInterpolation = AnimatedInterpolation;
exports.AnimatedObject = AnimatedObject;
exports.AnimatedProps = AnimatedProps;
exports.AnimatedStyle = AnimatedStyle;
exports.AnimatedValue = AnimatedValue;
exports.AnimatedValueArray = AnimatedValueArray;
exports.createAnimatedComponent = createAnimatedComponent;
exports.isAnimated = isAnimated;
exports.withExtend = withExtend;
//# sourceMappingURL=index.cjs.js.map
