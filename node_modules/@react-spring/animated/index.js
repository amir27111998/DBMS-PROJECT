import { is, createInterpolator, Globals, useForceUpdate, useOnce } from '@react-spring/shared';
import _extends from '@babel/runtime/helpers/esm/extends';
import { createAnimatedTransform, createAnimatedInterpolation, now, createAnimatedStyle, applyAnimatedValues } from '@react-spring/shared/globals';
export { createAnimatedInterpolation as interpolate } from '@react-spring/shared/globals';
import _objectWithoutPropertiesLoose from '@babel/runtime/helpers/esm/objectWithoutPropertiesLoose';
import React, { forwardRef, useRef, useCallback } from 'react';

function isAnimated(val) {
  return val instanceof Animated;
}
class Animated {
  constructor() {
    this.children = [];
  }

  getAnimatedValue() {
    return this.getValue();
  }

  getPayload() {
    return this.payload || this;
  }

  attach() {}

  detach() {}

  getChildren() {
    return this.children;
  }

  addChild(child) {
    if (this.children.length === 0) this.attach();
    this.children.push(child);
  }

  removeChild(child) {
    const index = this.children.indexOf(child);
    this.children.splice(index, 1);
    if (this.children.length === 0) this.detach();
  }

}
class AnimatedArray extends Animated {
  attach() {
    this.payload.forEach(p => isAnimated(p) && p.addChild(this));
  }

  detach() {
    this.payload.forEach(p => isAnimated(p) && p.removeChild(this));
  }

}
class AnimatedObject extends Animated {
  constructor(payload) {
    super();
    this.payload = payload;
  }

  getValue(animated) {
    if (animated === void 0) {
      animated = false;
    }

    const payload = {};

    for (const key in this.payload) {
      const value = this.payload[key];
      if (animated && !isAnimated(value)) continue;
      payload[key] = isAnimated(value) ? value[animated ? 'getAnimatedValue' : 'getValue']() : value;
    }

    return payload;
  }

  getAnimatedValue() {
    return this.getValue(true);
  }

  attach() {
    Object.values(this.payload).forEach(s => isAnimated(s) && s.addChild(this));
  }

  detach() {
    Object.values(this.payload).forEach(s => isAnimated(s) && s.removeChild(this));
  }

}

class AnimatedStyle extends AnimatedObject {
  constructor(style) {
    if (style === void 0) {
      style = {};
    }

    super(style.transform && createAnimatedTransform ? _extends({}, style, {
      transform: createAnimatedTransform(style.transform)
    }) : style);
  }

}

/**
 * Animated works by building a directed acyclic graph of dependencies
 * transparently when you render your Animated components.
 *
 *               new Animated.Value(0)
 *     .interpolate()        .interpolate()    new Animated.Value(1)
 *         opacity               translateY      scale
 *          style                         transform
 *         View#234                         style
 *                                         View#123
 *
 * A) Top Down phase
 * When an AnimatedValue is updated, we recursively go down through this
 * graph in order to find leaf nodes: the views that we flag as needing
 * an update.
 *
 * B) Bottom Up phase
 * When a view is flagged as needing an update, we recursively go back up
 * in order to build the new value that it needs. The reason why we need
 * this two-phases process is to deal with composite props such as
 * transform which can receive values from multiple parents.
 */

function addAnimatedStyles(node, styles) {
  if ('update' in node) {
    styles.add(node);
  } else {
    node.getChildren().forEach(child => addAnimatedStyles(child, styles));
  }
}

class AnimatedValue extends Animated {
  constructor(value) {
    var _this;

    super();
    _this = this;
    this.animatedStyles = new Set();
    this.done = false;

    this.setValue = function (value, flush) {
      if (flush === void 0) {
        flush = true;
      }

      _this.value = value;
      if (flush) _this.flush();
    };

    this.value = value;

    if (is.num(value)) {
      this.startPosition = value;
      this.lastPosition = value;
    }
  }

  static from(value) {
    return isAnimated(value) ? value : new AnimatedValue(value);
  }

  getValue() {
    return this.value;
  }

  interpolate() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return createAnimatedInterpolation(this, ...args);
  }

  reset(isActive) {
    if (is.num(this.value)) {
      this.startPosition = this.value;
      this.lastPosition = this.value;
      this.lastVelocity = isActive ? this.lastVelocity : undefined;
      this.lastTime = isActive ? this.lastTime : undefined;
      this.startTime = now();
    }

    this.done = false;
    this.animatedStyles.clear();
  }

  clearStyles() {
    this.animatedStyles.clear();
  }

  flush() {
    if (this.animatedStyles.size === 0) {
      addAnimatedStyles(this, this.animatedStyles);
    }

    this.animatedStyles.forEach(animatedStyle => animatedStyle.update());
  }

}

class AnimatedValueArray extends AnimatedArray {
  constructor(values) {
    super();
    this.payload = values;
  }

  getValue() {
    return this.payload.map(v => v.getValue());
  }

  setValue(value, flush) {
    if (flush === void 0) {
      flush = true;
    }

    if (is.arr(value)) {
      if (value.length === this.payload.length) {
        value.forEach((v, i) => this.payload[i].setValue(v, flush));
      }
    } else {
      this.payload.forEach(p => p.setValue(value, flush));
    }
  }

  interpolate() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return createAnimatedInterpolation(this, ...args);
  }

}

class AnimatedInterpolation extends AnimatedArray {
  constructor(parents, args) {
    super();
    this.calc = createInterpolator(...args);
    this.payload = Array.isArray(parents) ? parents.map(AnimatedValue.from) : parents instanceof AnimatedValueArray ? parents.getPayload() : [parents];
  }

  getValue() {
    const args = this.payload.map(value => value.getValue());
    return this.calc(...args);
  }

  interpolate() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return createAnimatedInterpolation(this, ...args);
  }

}

Globals.assign({
  createAnimatedStyle: style => new AnimatedStyle(style),
  createAnimatedInterpolation: function createAnimatedInterpolation(parents) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    return new AnimatedInterpolation(parents, args);
  }
});

/**
 * Wraps the `style` property with `AnimatedStyle`.
 */

class AnimatedProps extends AnimatedObject {
  constructor(props, callback) {
    super(props.style && createAnimatedStyle ? _extends({}, props, {
      style: createAnimatedStyle(props.style)
    }) : props);
    this.update = callback;
    this.attach();
  }

}

const createAnimatedComponent = Component => forwardRef((props, ref) => {
  const propsAnimated = useRef(null);
  const forceUpdate = useForceUpdate();
  const node = useRef(null);
  const attachProps = useCallback(props => {
    const oldPropsAnimated = propsAnimated.current;

    const callback = () => {
      const didUpdate = !!node.current && applyAnimatedValues(node.current, propsAnimated.current.getAnimatedValue()); // If no referenced node has been found, or the update target didn't have a
      // native-responder, then forceUpdate the animation ...

      if (didUpdate === false) forceUpdate();
    };

    propsAnimated.current = new AnimatedProps(props, callback);
    oldPropsAnimated && oldPropsAnimated.detach();
    return propsAnimated.current.getValue();
  }, []);
  useOnce(() => () => {
    propsAnimated.current && propsAnimated.current.detach();
  }); // TODO: Avoid special case for scrollTop/scrollLeft

  const _attachProps = attachProps(props),
        scrollTop = _attachProps.scrollTop,
        scrollLeft = _attachProps.scrollLeft,
        animatedProps = _objectWithoutPropertiesLoose(_attachProps, ["scrollTop", "scrollLeft"]); // Functions cannot have refs (see #569)


  const refFn = !is.fun(Component) || Component.prototype.isReactComponent ? value => node.current = updateRef(ref, value) : void 0;
  return React.createElement(Component, Object.assign({}, animatedProps, {
    ref: refFn
  }));
});

function updateRef(ref, value) {
  if (ref) {
    if (is.fun(ref)) ref(value);else ref.current = value;
  }

  return value;
}
/** Add an `extend` method to your `animated` factory function */


function withExtend(animated, options) {
  if (options === void 0) {
    options = {};
  }

  const self = animated;

  const extend = (arg, overrideKey) => {
    // Arrays avoid passing their index to `extend`
    if (is.arr(arg)) {
      return arg.forEach(arg => extend(arg));
    } // Object keys are always used over value inspection


    if (is.obj(arg)) {
      for (const key in arg) extend(arg[key], key);

      return;
    } // Use the `overrideKey` or inspect the value for a key


    let key = is.str(overrideKey) ? overrideKey : is.str(arg) ? arg : arg && is.str(arg.displayName) ? arg.displayName : is.fun(arg) ? arg.name : ''; // This lowercases the first letter of the key

    if (options.lowercase) {
      key = key[0].toLowerCase() + key.slice(1);
    } // NOTE(typescript): Properties are not yet inferred from the arguments of
    // the `extend` method and then attached to the `animated` function via
    // the return type.


    self[key] = animated(arg);
  };

  self.extend = function () {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    args.forEach(arg => extend(arg));
    return self;
  };

  return self;
}

export { Animated, AnimatedArray, AnimatedInterpolation, AnimatedObject, AnimatedProps, AnimatedStyle, AnimatedValue, AnimatedValueArray, createAnimatedComponent, isAnimated, withExtend };
//# sourceMappingURL=index.js.map
